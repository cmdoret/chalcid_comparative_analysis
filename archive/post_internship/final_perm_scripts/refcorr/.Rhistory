line.country <- ggplot(data=m.country, aes(x=mode, y=nbr_country, group=pair))+  geom_boxplot(aes(group=mode))+
geom_path(alpha=0.6) + theme_classic() + theme(axis.line.x = element_line (color="black"), axis.line.y = element_line (color="black")) +
ylab("Number of countries") + xlab("") + annotate("text", x=1.5, y=120, label="p = 0.0046", size=4)
grid.arrange(line.host, line.country, nrow=1, ncol=2)
# Latitude
minlat.asex <- by(data=manual$min_dist_eq[manual$mode=="asex"],manual$pair[manual$mode=="asex"],mean,simplify=T,na.rm=T)
minlat.sex <- by(data=manual$min_dist_eq[manual$mode=="sex"],manual$pair[manual$mode=="sex"],mean,simplify=T,na.rm=T)
df <- as.data.frame(cbind(minlat.asex, minlat.sex))
m.mindist <- reshape (df, varying=c("minlat.asex", "minlat.sex"), v.names = "min_dist_eq", timevar="mode", direction="long",
times = c("asex", "sex"), idvar="pair")
m.mindist<- merge(x=m.mindist,y=manual[,c("family","pair")],by="pair")
line.mindist <- ggplot(data=m.mindist, aes(x=mode, y=min_dist_eq, group=pair))+  geom_boxplot(aes(group=mode))+
geom_path(alpha=0.6) + theme_classic() + theme(axis.line.x = element_line (color="black"), axis.line.y = element_line (color="black")) +
ylab("Minimum distance to equator") + xlab("") + annotate("text", x=1.5, y=40, label="p = 0.63", size=4)
maxlat.asex <- by(data=manual$max_dist_eq[manual$mode=="asex"],manual$pair[manual$mode=="asex"],mean,simplify=T,na.rm=T)
maxlat.sex <- by(data=manual$max_dist_eq[manual$mode=="sex"],manual$pair[manual$mode=="sex"],mean,simplify=T,na.rm=T)
df <- as.data.frame(cbind(maxlat.asex, maxlat.sex))
m.maxdist <- reshape (df, varying=c("maxlat.asex", "maxlat.sex"), v.names = "max_dist_eq", timevar="mode", direction="long",
times = c("asex", "sex"), idvar="pair")
m.maxdist<- merge(x=m.maxdist,y=manual[,c("family","pair")],by="pair")
line.maxdist <- ggplot(data=m.maxdist, aes(x=mode, y=max_dist_eq, group=pair))+  geom_boxplot(aes(group=mode))+
geom_path(alpha=0.6) + theme_classic() + theme(axis.line.x = element_line (color="black"), axis.line.y = element_line (color="black")) +
ylab("Maximum distance to equator") + xlab("") + annotate("text", x=1.5, y=75, label="p = 0.0078", size=4)
latrange.asex <- by(data=manual$lat_range[manual$mode=="asex"],manual$pair[manual$mode=="asex"],mean,simplify=T,na.rm=T)
latrange.sex <- by(data=manual$lat_range[manual$mode=="sex"],manual$pair[manual$mode=="sex"],mean,simplify=T,na.rm=T)
df <- as.data.frame(cbind(latrange.asex, latrange.sex))
m.latrange <- reshape (df, varying=c("latrange.asex", "latrange.sex"), v.names = "lat_range", timevar="mode", direction="long",
times = c("asex", "sex"), idvar="pair")
m.latrange<- merge(x=m.latrange,y=manual[,c("family","pair")],by="pair")
line.latrange <- ggplot(data=m.latrange, aes(x=mode, y=lat_range, group=pair))+  geom_boxplot(aes(group=mode))+
geom_path(alpha=0.6) + theme_classic() + theme(axis.line.x = element_line (color="black"), axis.line.y = element_line (color="black")) +
ylab("Latitude range") + xlab("") + annotate("text", x=1.5, y=120, label="p = 0.0328", size=4)
grid.arrange(line.country,line.host,line.mindist,line.maxdist,line.latrange,nrow=1)
host.asex <- by (data=manual$host_spp[manual$mode=="asex"], manual$pair[manual$mode=="asex"] , mean, simplify=T, na.rm=T)
host.sex <- by (data=manual$host_spp[manual$mode=="sex"], manual$pair[manual$mode=="sex"] , mean, simplify=T, na.rm=T)
df <- as.data.frame(cbind(host.asex, host.sex))
m.host <- reshape (df, varying=c("host.asex", "host.sex"), v.names = "host_spp", timevar="mode", direction="long",
times = c("asex", "sex"), idvar="pair")
m.host<- merge(x=m.host,y=manual[,c("family","pair")],by="pair")
line.host <- ggplot(data=m.host, aes(x=mode, y=host_spp, group=pair)) +
geom_path(alpha=0.6) + theme_classic() + theme(axis.line.x = element_line (color="black"), axis.line.y = element_line (color="black")) +
ylab("Number of host species") + xlab("") + annotate("text", x=1.5, y=170, label="p = 0.0042", size=4)
country.asex <- by (data=manual$nbr_country[manual$mode=="asex"], manual$pair[manual$mode=="asex"] , mean, simplify=T, na.rm=T)
country.sex <- by (data=manual$nbr_country[manual$mode=="sex"], manual$pair[manual$mode=="sex"] , mean, simplify=T, na.rm=T)
df <- as.data.frame(cbind(country.asex, country.sex))
m.country <- reshape (df, varying=c("country.asex", "country.sex"), v.names = "nbr_country", timevar="mode", direction="long",
times = c("asex", "sex"), idvar="pair")
m.country<- merge(x=m.country,y=manual[,c("family","pair")],by="pair")
line.country <- ggplot(data=m.country, aes(x=mode, y=nbr_country, group=pair))+
geom_path(alpha=0.6) + theme_classic() + theme(axis.line.x = element_line (color="black"), axis.line.y = element_line (color="black")) +
ylab("Number of countries") + xlab("") + annotate("text", x=1.5, y=120, label="p = 0.0046", size=4)
grid.arrange(line.host, line.country, nrow=1, ncol=2)
# Latitude
minlat.asex <- by(data=manual$min_dist_eq[manual$mode=="asex"],manual$pair[manual$mode=="asex"],mean,simplify=T,na.rm=T)
minlat.sex <- by(data=manual$min_dist_eq[manual$mode=="sex"],manual$pair[manual$mode=="sex"],mean,simplify=T,na.rm=T)
df <- as.data.frame(cbind(minlat.asex, minlat.sex))
m.mindist <- reshape (df, varying=c("minlat.asex", "minlat.sex"), v.names = "min_dist_eq", timevar="mode", direction="long",
times = c("asex", "sex"), idvar="pair")
m.mindist<- merge(x=m.mindist,y=manual[,c("family","pair")],by="pair")
line.mindist <- ggplot(data=m.mindist, aes(x=mode, y=min_dist_eq, group=pair))+
geom_path(alpha=0.6) + theme_classic() + theme(axis.line.x = element_line (color="black"), axis.line.y = element_line (color="black")) +
ylab("Minimum distance to equator") + xlab("") + annotate("text", x=1.5, y=40, label="p = 0.63", size=4)
maxlat.asex <- by(data=manual$max_dist_eq[manual$mode=="asex"],manual$pair[manual$mode=="asex"],mean,simplify=T,na.rm=T)
maxlat.sex <- by(data=manual$max_dist_eq[manual$mode=="sex"],manual$pair[manual$mode=="sex"],mean,simplify=T,na.rm=T)
df <- as.data.frame(cbind(maxlat.asex, maxlat.sex))
m.maxdist <- reshape (df, varying=c("maxlat.asex", "maxlat.sex"), v.names = "max_dist_eq", timevar="mode", direction="long",
times = c("asex", "sex"), idvar="pair")
m.maxdist<- merge(x=m.maxdist,y=manual[,c("family","pair")],by="pair")
line.maxdist <- ggplot(data=m.maxdist, aes(x=mode, y=max_dist_eq, group=pair))+
geom_path(alpha=0.6) + theme_classic() + theme(axis.line.x = element_line (color="black"), axis.line.y = element_line (color="black")) +
ylab("Maximum distance to equator") + xlab("") + annotate("text", x=1.5, y=75, label="p = 0.0078", size=4)
latrange.asex <- by(data=manual$lat_range[manual$mode=="asex"],manual$pair[manual$mode=="asex"],mean,simplify=T,na.rm=T)
latrange.sex <- by(data=manual$lat_range[manual$mode=="sex"],manual$pair[manual$mode=="sex"],mean,simplify=T,na.rm=T)
df <- as.data.frame(cbind(latrange.asex, latrange.sex))
m.latrange <- reshape (df, varying=c("latrange.asex", "latrange.sex"), v.names = "lat_range", timevar="mode", direction="long",
times = c("asex", "sex"), idvar="pair")
m.latrange<- merge(x=m.latrange,y=manual[,c("family","pair")],by="pair")
line.latrange <- ggplot(data=m.latrange, aes(x=mode, y=lat_range, group=pair))+
geom_path(alpha=0.6) + theme_classic() + theme(axis.line.x = element_line (color="black"), axis.line.y = element_line (color="black")) +
ylab("Latitude range") + xlab("") + annotate("text", x=1.5, y=120, label="p = 0.0328", size=4)
grid.arrange(line.country,line.host,line.mindist,line.maxdist,line.latrange,nrow=1)
auto <- read.csv("~/Dropbox/Cyril-Casper_shared/for_publication/auto_data.csv")
head(auto)
random_test <- function(x,y) {  #x: data, y:genus
genus_name <- subset(x, genus == y)$genus
species_name <- subset(x, genus == y)$species
var <- subset(x, genus == y)[,variable]
# Sample without replacement
random_mode <- sample(subset(x, genus == y)$mode)
# Return a partial data frame (for each genus)
return(data.frame(genus_name, species_name, var, random_mode))
}
# For each genus, run the random_test() function.
zval_model <- function(data, n.genera, count=F){
# Complete data frame initialization.
ref.distri <- data.frame(x= character(0), y= character(0), z = character(0))
for (t in 1:n.genera) {
# Sub data frame (for each genus).
part_distri <- random_test(data, levels(data$genus)[t])
# Concatenation of each sub data frames.
ref.distri <- rbind(ref.distri, part_distri)
}
#print(ref.distri)
# Model
if(count){
m1 <- glmer(var ~ random_mode + (1|genus_name), data = ref.distri,family = "poisson")
st <- "z"
} else{
m1 <- lmer(var ~ random_mode + (1|genus_name), data = ref.distri)
st <- "t"
}
return(coef(summary(m1))[2, paste0(st," value")]) # Return zvalue
}
library(nlme); library(lme4);library(parallel)
data <- auto
variable = "host_spp"
v=variable
fmla <- as.formula(paste(variable,"~ mode + (1|genus)",sep=" "))
glmer(fmla, data = cut_data,family = "poisson")
glmer(fmla, data = data,family = "poisson")
m_host <- glmer(fmla, data = data,family = "poisson")
coef(summary(m_host))[2, paste0(st, " value")]
coef(summary(m_host))[2, paste0("z", " value")]
coef(summary(m_host))
fmla <- as.formula(paste(variable,"~ mode + (1|genus) + (1|ref)",sep=" "))
m_host <- glmer(fmla, data = data,family = "poisson")
str(data$"Remifentanil")
str(data$ref)
coef(m_host)
coef(sumary(m_host))
coef(summary(m_host))
coef(summary(m_host))[2, paste0("z", " value")]
random_test <- function(x,y) {  #x: data, y:genus
genus_name <- subset(x, genus == y)$genus
species_name <- subset(x, genus == y)$species
var <- subset(x, genus == y)[,variable]
ref_list <- subset(x, genus==y)$ref
# Sample without replacement
random_mode <- sample(subset(x, genus == y)$mode)
# Return a partial data frame (for each genus)
return(data.frame(ref_list,genus_name, species_name, var, random_mode))
}
# For each genus, run the random_test() function.
zval_model <- function(data, n.genera, count=F){
# Complete data frame initialization.
ref.distri <- data.frame(w=character(0),x= character(0), y= character(0), z = character(0))
for (t in 1:n.genera) {
# Sub data frame (for each genus).
part_distri <- random_test(data, levels(data$genus)[t])
# Concatenation of each sub data frames.
ref.distri <- rbind(ref.distri, part_distri)
}
#print(ref.distri)
# Model
if(count){
m1 <- glmer(var ~ random_mode + (1|genus_name) + (1|ref_list), data = ref.distri,family = "poisson")
st <- "z"
} else{
m1 <- lmer(var ~ random_mode + (1|genus_name) + (1|ref_list), data = ref.distri)
st <- "t"
}
return(coef(summary(m1))[2, paste0(st," value")]) # Return zvalue
}
library(nlme); library(lme4);library(parallel)
data <- read.csv("./auto_data.csv", header=T)
nboot <- 10
for(cutoff in -1:20){
cut_data <- data[data$ref>cutoff,] # remove species very few studies
n.genera <- length(levels(cut_data$genus)) #number of genera
l.genus <- as.vector(table(cut_data$genus)) #list w/ number of species per genus
if(cutoff<0){
pdf(paste0("auto_10ksim_nocutoff.pdf"), width = 15, height=12)
}else{
pdf(paste0("auto_10ksim_GT", cutoff,"ref.pdf"), width = 15, height=12)
}
par(mfrow=c(4,2))
cl <- makeCluster(detectCores()-0)
#get library support needed to run the code
clusterEvalQ(cl,c(library(nlme),library(lme4)))
# Export variables and functions to all nodes in the cluster
clusterExport(cl,c("random_test","zval_model","cut_data","n.genera"))
for(v in c("nbr_country","max_dist_eq","min_dist_eq","lat_mean","lat_median","lat_range","host_spp")){
variable = v
start_time <- proc.time()[3]
clusterExport(cl,"variable")
fmla <- as.formula(paste(variable,"~ mode + (1|genus) + (1|ref)",sep=" "))
if(v %in% c("nbr_country","host_spp")){
if(v=="host_spp"){
cut_data <- cut_data[!cut_data$host_spp ==0,] # remove species with no hosts described
}
clusterExport(cl,"cut_data")
zval.reference <-parSapply(cl, 1:nboot, function(i,...){zval_model(cut_data,n.genera,count=T)})
m_host <- glmer(fmla, data = cut_data,family = "poisson")
st <- "z"
}
else{
zval.reference <-parSapply(cl, 1:nboot, function(i,...){zval_model(cut_data,n.genera)})
m_host <- lmer(fmla, data = cut_data)
st <- "t"
}
z.obs <- coef(summary(m_host))[2, paste0(st, " value")]
pval1T <- ifelse(z.obs>0,sum(z.obs<=zval.reference)/nboot,sum(z.obs>=zval.reference)/nboot)
pval <- 2*min(sum(z.obs<=zval.reference)/nboot,sum(z.obs>=zval.reference)/nboot)
hist(main=paste0(variable, "\n",st,"-value = ", round(z.obs,3),
", P = ",pval),zval.reference,
breaks = 100, xlim=c(min(c(zval.reference,z.obs)), max(c(zval.reference,z.obs)))) # Vector of nboot pvalues
abline(v=z.obs, col="red", lwd=3)
print(paste0("P-value for ", variable, " is: ", pval))
print(paste0(nboot, " simulations for ", variable, " took ", unname(proc.time()[3]-start_time), " seconds"))
print(paste0("n=",nrow(cut_data)))
print("=====================================================")
line = paste(cutoff,variable,pval1T,pval,round(z.obs,3),sep=",")
write(line,file="out_auto.csv",append=T)
}
stopCluster(cl)
dev.off()
}
stopCluster(cl)
dev.off()
########################################################
#======================================================#
########################################################
#Note: If run on the cluster, needs R 3.2.2 as packages are not installed for R 3.3
# Run full script with all different references cutoffs
#(removes the need to manually change variables)
random_test <- function(x,y) {  #x: data, y:genus
genus_name <- subset(x, genus == y)$genus
species_name <- subset(x, genus == y)$species
var <- subset(x, genus == y)[,variable]
ref_list <- subset(x, genus==y)$ref
# Sample without replacement
random_mode <- sample(subset(x, genus == y)$mode)
# Return a partial data frame (for each genus)
return(data.frame(ref_list,genus_name, species_name, var, random_mode))
}
# For each genus, run the random_test() function.
zval_model <- function(data, n.genera, count=F){
# Complete data frame initialization.
ref.distri <- data.frame(w=character(0),x= character(0), y= character(0), z = character(0))
for (t in 1:n.genera) {
# Sub data frame (for each genus).
part_distri <- random_test(data, levels(data$genus)[t])
# Concatenation of each sub data frames.
ref.distri <- rbind(ref.distri, part_distri)
}
#print(ref.distri)
# Model
if(count){
m1 <- glmer(var ~ random_mode + (1|genus_name) + (1|ref_list), data = ref.distri,family = "poisson")
st <- "z"
} else{
m1 <- lmer(var ~ random_mode + (1|genus_name) + (1|ref_list), data = ref.distri)
st <- "t"
}
return(coef(summary(m1))[2, paste0(st," value")]) # Return zvalue
}
library(nlme); library(lme4);library(parallel)
data <- read.csv("./auto_data.csv", header=T)
nboot <- 10
# Simulations are shared among the nodes and the results are put together in the end.
#zval.reference <- replicate(nboot, zval_model(cut_data, n.genera))
for(cutoff in -1:20){
cut_data <- data[data$ref>cutoff,] # remove species very few studies
n.genera <- length(levels(cut_data$genus)) #number of genera
l.genus <- as.vector(table(cut_data$genus)) #list w/ number of species per genus
if(cutoff<0){
pdf(paste0("pubauto_10ksim_nocutoff.pdf"), width = 15, height=12)
}else{
pdf(paste0("pubauto_10ksim_GT", cutoff,"ref.pdf"), width = 15, height=12)
}
par(mfrow=c(4,2))
cl <- makeCluster(detectCores()-0)
#get library support needed to run the code
clusterEvalQ(cl,c(library(nlme),library(lme4)))
# Export variables and functions to all nodes in the cluster
clusterExport(cl,c("random_test","zval_model","cut_data","n.genera"))
for(v in c("nbr_country","max_dist_eq","min_dist_eq","lat_mean","lat_median","lat_range","host_spp")){
variable = v
start_time <- proc.time()[3]
clusterExport(cl,"variable")
fmla <- as.formula(paste(variable,"~ mode + (1|genus) + (1|ref)",sep=" "))
if(v %in% c("nbr_country","host_spp")){
if(v=="host_spp"){
cut_data <- cut_data[!cut_data$host_spp ==0,] # remove species with no hosts described
}
clusterExport(cl,"cut_data")
zval.reference <-parSapply(cl, 1:nboot, function(i,...){zval_model(cut_data,n.genera,count=T)})
m_host <- glmer(fmla, data = cut_data,family = "poisson")
st <- "z"
}
else{
zval.reference <-parSapply(cl, 1:nboot, function(i,...){zval_model(cut_data,n.genera)})
m_host <- lmer(fmla, data = cut_data)
st <- "t"
}
z.obs <- coef(summary(m_host))[2, paste0(st, " value")]
pval1T <- ifelse(z.obs>0,sum(z.obs<=zval.reference)/nboot,sum(z.obs>=zval.reference)/nboot)
pval <- 2*min(sum(z.obs<=zval.reference)/nboot,sum(z.obs>=zval.reference)/nboot)
hist(main=paste0(variable, "\n",st,"-value = ", round(z.obs,3),
", P = ",pval),zval.reference,
breaks = 100, xlim=c(min(c(zval.reference,z.obs)), max(c(zval.reference,z.obs)))) # Vector of nboot pvalues
abline(v=z.obs, col="red", lwd=3)
print(paste0("P-value for ", variable, " is: ", pval))
print(paste0(nboot, " simulations for ", variable, " took ", unname(proc.time()[3]-start_time), " seconds"))
print(paste0("n=",nrow(cut_data)))
print("=====================================================")
line = paste(cutoff,variable,pval1T,pval,round(z.obs,3),sep=",")
write(line,file="out_auto.csv",append=T)
}
stopCluster(cl)
dev.off()
}
getwd()
setwd("~/Documents/Internship/post_internship/final_perm_scripts/refcorr/")
random_test <- function(x,y) {  #x: data, y:genus
genus_name <- subset(x, genus == y)$genus
species_name <- subset(x, genus == y)$species
var <- subset(x, genus == y)[,variable]
ref_list <- subset(x, genus==y)$ref
# Sample without replacement
random_mode <- sample(subset(x, genus == y)$mode)
# Return a partial data frame (for each genus)
return(data.frame(ref_list,genus_name, species_name, var, random_mode))
}
# For each genus, run the random_test() function.
zval_model <- function(data, n.genera, count=F){
# Complete data frame initialization.
ref.distri <- data.frame(w=character(0),x= character(0), y= character(0), z = character(0))
for (t in 1:n.genera) {
# Sub data frame (for each genus).
part_distri <- random_test(data, levels(data$genus)[t])
# Concatenation of each sub data frames.
ref.distri <- rbind(ref.distri, part_distri)
}
#print(ref.distri)
# Model
if(count){
m1 <- glmer(var ~ random_mode + (1|genus_name) + (1|ref_list), data = ref.distri,family = "poisson")
st <- "z"
} else{
m1 <- lmer(var ~ random_mode + (1|genus_name) + (1|ref_list), data = ref.distri)
st <- "t"
}
return(coef(summary(m1))[2, paste0(st," value")]) # Return zvalue
}
library(nlme); library(lme4);library(parallel)
data <- read.csv("./auto_data.csv", header=T)
nboot <- 10
# Simulations are shared among the nodes and the results are put together in the end.
#zval.reference <- replicate(nboot, zval_model(cut_data, n.genera))
for(cutoff in -1:20){
cut_data <- data[data$ref>cutoff,] # remove species very few studies
n.genera <- length(levels(cut_data$genus)) #number of genera
l.genus <- as.vector(table(cut_data$genus)) #list w/ number of species per genus
if(cutoff<0){
pdf(paste0("pubauto_10ksim_nocutoff.pdf"), width = 15, height=12)
}else{
pdf(paste0("pubauto_10ksim_GT", cutoff,"ref.pdf"), width = 15, height=12)
}
par(mfrow=c(4,2))
cl <- makeCluster(detectCores()-0)
#get library support needed to run the code
clusterEvalQ(cl,c(library(nlme),library(lme4)))
# Export variables and functions to all nodes in the cluster
clusterExport(cl,c("random_test","zval_model","cut_data","n.genera"))
for(v in c("nbr_country","max_dist_eq","min_dist_eq","lat_mean","lat_median","lat_range","host_spp")){
variable = v
start_time <- proc.time()[3]
clusterExport(cl,"variable")
fmla <- as.formula(paste(variable,"~ mode + (1|genus) + (1|ref)",sep=" "))
if(v %in% c("nbr_country","host_spp")){
if(v=="host_spp"){
cut_data <- cut_data[!cut_data$host_spp ==0,] # remove species with no hosts described
}
clusterExport(cl,"cut_data")
zval.reference <-parSapply(cl, 1:nboot, function(i,...){zval_model(cut_data,n.genera,count=T)})
m_host <- glmer(fmla, data = cut_data,family = "poisson")
st <- "z"
}
else{
zval.reference <-parSapply(cl, 1:nboot, function(i,...){zval_model(cut_data,n.genera)})
m_host <- lmer(fmla, data = cut_data)
st <- "t"
}
z.obs <- coef(summary(m_host))[2, paste0(st, " value")]
pval1T <- ifelse(z.obs>0,sum(z.obs<=zval.reference)/nboot,sum(z.obs>=zval.reference)/nboot)
pval <- 2*min(sum(z.obs<=zval.reference)/nboot,sum(z.obs>=zval.reference)/nboot)
hist(main=paste0(variable, "\n",st,"-value = ", round(z.obs,3),
", P = ",pval),zval.reference,
breaks = 100, xlim=c(min(c(zval.reference,z.obs)), max(c(zval.reference,z.obs)))) # Vector of nboot pvalues
abline(v=z.obs, col="red", lwd=3)
print(paste0("P-value for ", variable, " is: ", pval))
print(paste0(nboot, " simulations for ", variable, " took ", unname(proc.time()[3]-start_time), " seconds"))
print(paste0("n=",nrow(cut_data)))
print("=====================================================")
line = paste(cutoff,variable,pval1T,pval,round(z.obs,3),sep=",")
write(line,file="out_auto.csv",append=T)
}
stopCluster(cl)
dev.off()
}
stopCluster(cl)
dev.off()
setwd("~/Documents/Internship/post_internship/final_perm_scripts/refcorr/")
########################################################
#======================================================#
########################################################
#Note: If run on the cluster, needs R 3.2.2 as packages are not installed for R 3.3
# Run full script with all different references cutoffs
#(removes the need to manually change variables)
random_test <- function(x,y) {  #x: data, y:genus
genus_name <- subset(x, genus == y)$genus
species_name <- subset(x, genus == y)$species
var <- subset(x, genus == y)[,variable]
ref_list <- subset(x, genus==y)$ref
# Sample without replacement
random_mode <- sample(subset(x, genus == y)$mode)
# Return a partial data frame (for each genus)
return(data.frame(ref_list,genus_name, species_name, var, random_mode))
}
# For each genus, run the random_test() function.
zval_model <- function(data, n.genera, count=F){
# Complete data frame initialization.
ref.distri <- data.frame(w=character(0),x= character(0), y= character(0), z = character(0))
for (t in 1:n.genera) {
# Sub data frame (for each genus).
part_distri <- random_test(data, levels(data$genus)[t])
# Concatenation of each sub data frames.
ref.distri <- rbind(ref.distri, part_distri)
}
#print(ref.distri)
# Model
if(count){
m1 <- glmer(var ~ random_mode + (1|genus_name) + (1|ref_list), data = ref.distri,family = "poisson")
st <- "z"
} else{
m1 <- lmer(var ~ random_mode + (1|genus_name) + (1|ref_list), data = ref.distri)
st <- "t"
}
return(coef(summary(m1))[2, paste0(st," value")]) # Return zvalue
}
library(nlme); library(lme4);library(parallel)
data <- read.csv("./auto_data.csv", header=T)
nboot <- 10000
# Simulations are shared among the nodes and the results are put together in the end.
#zval.reference <- replicate(nboot, zval_model(cut_data, n.genera))
for(cutoff in 0:20){
cut_data <- data[data$ref>cutoff,] # remove species very few studies
n.genera <- length(levels(cut_data$genus)) #number of genera
l.genus <- as.vector(table(cut_data$genus)) #list w/ number of species per genus
if(cutoff<0){
pdf(paste0("pubauto_10ksim_nocutoff.pdf"), width = 15, height=12)
}else{
pdf(paste0("pubauto_10ksim_GT", cutoff,"ref.pdf"), width = 15, height=12)
}
par(mfrow=c(4,2))
cl <- makeCluster(detectCores()-1)
#get library support needed to run the code
clusterEvalQ(cl,c(library(nlme),library(lme4)))
# Export variables and functions to all nodes in the cluster
clusterExport(cl,c("random_test","zval_model","cut_data","n.genera"))
for(v in c("nbr_country","max_dist_eq","min_dist_eq","lat_mean","lat_median","lat_range","host_spp")){
variable = v
start_time <- proc.time()[3]
clusterExport(cl,"variable")
fmla <- as.formula(paste(variable,"~ mode + (1|genus) + (1|ref)",sep=" "))
if(v %in% c("nbr_country","host_spp")){
if(v=="host_spp"){
cut_data <- cut_data[!cut_data$host_spp ==0,] # remove species with no hosts described
}
clusterExport(cl,"cut_data")
zval.reference <-parSapply(cl, 1:nboot, function(i,...){zval_model(cut_data,n.genera,count=T)})
m_host <- glmer(fmla, data = cut_data,family = "poisson")
st <- "z"
}
else{
zval.reference <-parSapply(cl, 1:nboot, function(i,...){zval_model(cut_data,n.genera)})
m_host <- lmer(fmla, data = cut_data)
st <- "t"
}
z.obs <- coef(summary(m_host))[2, paste0(st, " value")]
pval1T <- ifelse(z.obs>0,sum(z.obs<=zval.reference)/nboot,sum(z.obs>=zval.reference)/nboot)
pval <- 2*min(sum(z.obs<=zval.reference)/nboot,sum(z.obs>=zval.reference)/nboot)
hist(main=paste0(variable, "\n",st,"-value = ", round(z.obs,3),
", P = ",pval),zval.reference,
breaks = 100, xlim=c(min(c(zval.reference,z.obs)), max(c(zval.reference,z.obs)))) # Vector of nboot pvalues
abline(v=z.obs, col="red", lwd=3)
print(paste0("P-value for ", variable, " is: ", pval))
print(paste0(nboot, " simulations for ", variable, " took ", unname(proc.time()[3]-start_time), " seconds"))
print(paste0("n=",nrow(cut_data)))
print("=====================================================")
line = paste(cutoff,variable,pval1T,pval,round(z.obs,3),sep=",")
write(line,file="out_auto.csv",append=T)
}
stopCluster(cl)
dev.off()
}
stopCluster(cl)
dev.off()
lmer(fmla, data = cut_data)
fmla <- as.formula(paste(variable,"~ mode + (1|genus)",sep=" "))
lmer(fmla, data = cut_data)
start_time <- proc.time()[3]
print(paste0("took ", unname(proc.time()[3]-start_time), " seconds"))
start_time <- proc.time()[3]
fmla <- as.formula(paste(variable,"~ mode + (1|genus) + (1|ref)",sep=" "))
glmer(fmla, data = cut_data,family = "poisson")
print(paste0("took ", unname(proc.time()[3]-start_time), " seconds"))
start_time <- proc.time()[3]
fmla <- as.formula(paste(variable,"~ mode + (1|genus)",sep=" "))
glmer(fmla, data = cut_data,family = "poisson")
print(paste0("took ", unname(proc.time()[3]-start_time), " seconds"))
